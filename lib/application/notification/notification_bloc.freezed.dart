// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'notification_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$NotificationEventTearOff {
  const _$NotificationEventTearOff();

  _Init init() {
    return const _Init();
  }

  _LoadSettings loadSettings() {
    return const _LoadSettings();
  }

  _TogglePushNotification togglePushNotification() {
    return const _TogglePushNotification();
  }
}

/// @nodoc
const $NotificationEvent = _$NotificationEventTearOff();

/// @nodoc
mixin _$NotificationEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loadSettings,
    required TResult Function() togglePushNotification,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loadSettings,
    TResult Function()? togglePushNotification,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loadSettings,
    TResult Function()? togglePushNotification,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_LoadSettings value) loadSettings,
    required TResult Function(_TogglePushNotification value)
        togglePushNotification,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_LoadSettings value)? loadSettings,
    TResult Function(_TogglePushNotification value)? togglePushNotification,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_LoadSettings value)? loadSettings,
    TResult Function(_TogglePushNotification value)? togglePushNotification,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NotificationEventCopyWith<$Res> {
  factory $NotificationEventCopyWith(
          NotificationEvent value, $Res Function(NotificationEvent) then) =
      _$NotificationEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$NotificationEventCopyWithImpl<$Res>
    implements $NotificationEventCopyWith<$Res> {
  _$NotificationEventCopyWithImpl(this._value, this._then);

  final NotificationEvent _value;
  // ignore: unused_field
  final $Res Function(NotificationEvent) _then;
}

/// @nodoc
abstract class _$InitCopyWith<$Res> {
  factory _$InitCopyWith(_Init value, $Res Function(_Init) then) =
      __$InitCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitCopyWithImpl<$Res> extends _$NotificationEventCopyWithImpl<$Res>
    implements _$InitCopyWith<$Res> {
  __$InitCopyWithImpl(_Init _value, $Res Function(_Init) _then)
      : super(_value, (v) => _then(v as _Init));

  @override
  _Init get _value => super._value as _Init;
}

/// @nodoc

class _$_Init implements _Init {
  const _$_Init();

  @override
  String toString() {
    return 'NotificationEvent.init()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Init);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loadSettings,
    required TResult Function() togglePushNotification,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loadSettings,
    TResult Function()? togglePushNotification,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loadSettings,
    TResult Function()? togglePushNotification,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_LoadSettings value) loadSettings,
    required TResult Function(_TogglePushNotification value)
        togglePushNotification,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_LoadSettings value)? loadSettings,
    TResult Function(_TogglePushNotification value)? togglePushNotification,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_LoadSettings value)? loadSettings,
    TResult Function(_TogglePushNotification value)? togglePushNotification,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class _Init implements NotificationEvent {
  const factory _Init() = _$_Init;
}

/// @nodoc
abstract class _$LoadSettingsCopyWith<$Res> {
  factory _$LoadSettingsCopyWith(
          _LoadSettings value, $Res Function(_LoadSettings) then) =
      __$LoadSettingsCopyWithImpl<$Res>;
}

/// @nodoc
class __$LoadSettingsCopyWithImpl<$Res>
    extends _$NotificationEventCopyWithImpl<$Res>
    implements _$LoadSettingsCopyWith<$Res> {
  __$LoadSettingsCopyWithImpl(
      _LoadSettings _value, $Res Function(_LoadSettings) _then)
      : super(_value, (v) => _then(v as _LoadSettings));

  @override
  _LoadSettings get _value => super._value as _LoadSettings;
}

/// @nodoc

class _$_LoadSettings implements _LoadSettings {
  const _$_LoadSettings();

  @override
  String toString() {
    return 'NotificationEvent.loadSettings()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _LoadSettings);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loadSettings,
    required TResult Function() togglePushNotification,
  }) {
    return loadSettings();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loadSettings,
    TResult Function()? togglePushNotification,
  }) {
    return loadSettings?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loadSettings,
    TResult Function()? togglePushNotification,
    required TResult orElse(),
  }) {
    if (loadSettings != null) {
      return loadSettings();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_LoadSettings value) loadSettings,
    required TResult Function(_TogglePushNotification value)
        togglePushNotification,
  }) {
    return loadSettings(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_LoadSettings value)? loadSettings,
    TResult Function(_TogglePushNotification value)? togglePushNotification,
  }) {
    return loadSettings?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_LoadSettings value)? loadSettings,
    TResult Function(_TogglePushNotification value)? togglePushNotification,
    required TResult orElse(),
  }) {
    if (loadSettings != null) {
      return loadSettings(this);
    }
    return orElse();
  }
}

abstract class _LoadSettings implements NotificationEvent {
  const factory _LoadSettings() = _$_LoadSettings;
}

/// @nodoc
abstract class _$TogglePushNotificationCopyWith<$Res> {
  factory _$TogglePushNotificationCopyWith(_TogglePushNotification value,
          $Res Function(_TogglePushNotification) then) =
      __$TogglePushNotificationCopyWithImpl<$Res>;
}

/// @nodoc
class __$TogglePushNotificationCopyWithImpl<$Res>
    extends _$NotificationEventCopyWithImpl<$Res>
    implements _$TogglePushNotificationCopyWith<$Res> {
  __$TogglePushNotificationCopyWithImpl(_TogglePushNotification _value,
      $Res Function(_TogglePushNotification) _then)
      : super(_value, (v) => _then(v as _TogglePushNotification));

  @override
  _TogglePushNotification get _value => super._value as _TogglePushNotification;
}

/// @nodoc

class _$_TogglePushNotification implements _TogglePushNotification {
  const _$_TogglePushNotification();

  @override
  String toString() {
    return 'NotificationEvent.togglePushNotification()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _TogglePushNotification);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loadSettings,
    required TResult Function() togglePushNotification,
  }) {
    return togglePushNotification();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loadSettings,
    TResult Function()? togglePushNotification,
  }) {
    return togglePushNotification?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loadSettings,
    TResult Function()? togglePushNotification,
    required TResult orElse(),
  }) {
    if (togglePushNotification != null) {
      return togglePushNotification();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_LoadSettings value) loadSettings,
    required TResult Function(_TogglePushNotification value)
        togglePushNotification,
  }) {
    return togglePushNotification(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_LoadSettings value)? loadSettings,
    TResult Function(_TogglePushNotification value)? togglePushNotification,
  }) {
    return togglePushNotification?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_LoadSettings value)? loadSettings,
    TResult Function(_TogglePushNotification value)? togglePushNotification,
    required TResult orElse(),
  }) {
    if (togglePushNotification != null) {
      return togglePushNotification(this);
    }
    return orElse();
  }
}

abstract class _TogglePushNotification implements NotificationEvent {
  const factory _TogglePushNotification() = _$_TogglePushNotification;
}

/// @nodoc
class _$NotificationStateTearOff {
  const _$NotificationStateTearOff();

  _NotificationState call(
      {required Option<StreamSubscription> notificationSubscription,
      required bool isLoading,
      required bool isInitialized,
      required bool isPushNotificationActive,
      required bool isNewMessageAlertActive,
      required bool isLikeNotificationActive,
      required bool isChatTimerNotificationActive}) {
    return _NotificationState(
      notificationSubscription: notificationSubscription,
      isLoading: isLoading,
      isInitialized: isInitialized,
      isPushNotificationActive: isPushNotificationActive,
      isNewMessageAlertActive: isNewMessageAlertActive,
      isLikeNotificationActive: isLikeNotificationActive,
      isChatTimerNotificationActive: isChatTimerNotificationActive,
    );
  }
}

/// @nodoc
const $NotificationState = _$NotificationStateTearOff();

/// @nodoc
mixin _$NotificationState {
  Option<StreamSubscription> get notificationSubscription =>
      throw _privateConstructorUsedError;
  bool get isLoading => throw _privateConstructorUsedError;
  bool get isInitialized => throw _privateConstructorUsedError;
  bool get isPushNotificationActive => throw _privateConstructorUsedError;
  bool get isNewMessageAlertActive => throw _privateConstructorUsedError;
  bool get isLikeNotificationActive => throw _privateConstructorUsedError;
  bool get isChatTimerNotificationActive => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $NotificationStateCopyWith<NotificationState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NotificationStateCopyWith<$Res> {
  factory $NotificationStateCopyWith(
          NotificationState value, $Res Function(NotificationState) then) =
      _$NotificationStateCopyWithImpl<$Res>;
  $Res call(
      {Option<StreamSubscription> notificationSubscription,
      bool isLoading,
      bool isInitialized,
      bool isPushNotificationActive,
      bool isNewMessageAlertActive,
      bool isLikeNotificationActive,
      bool isChatTimerNotificationActive});
}

/// @nodoc
class _$NotificationStateCopyWithImpl<$Res>
    implements $NotificationStateCopyWith<$Res> {
  _$NotificationStateCopyWithImpl(this._value, this._then);

  final NotificationState _value;
  // ignore: unused_field
  final $Res Function(NotificationState) _then;

  @override
  $Res call({
    Object? notificationSubscription = freezed,
    Object? isLoading = freezed,
    Object? isInitialized = freezed,
    Object? isPushNotificationActive = freezed,
    Object? isNewMessageAlertActive = freezed,
    Object? isLikeNotificationActive = freezed,
    Object? isChatTimerNotificationActive = freezed,
  }) {
    return _then(_value.copyWith(
      notificationSubscription: notificationSubscription == freezed
          ? _value.notificationSubscription
          : notificationSubscription // ignore: cast_nullable_to_non_nullable
              as Option<StreamSubscription>,
      isLoading: isLoading == freezed
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      isInitialized: isInitialized == freezed
          ? _value.isInitialized
          : isInitialized // ignore: cast_nullable_to_non_nullable
              as bool,
      isPushNotificationActive: isPushNotificationActive == freezed
          ? _value.isPushNotificationActive
          : isPushNotificationActive // ignore: cast_nullable_to_non_nullable
              as bool,
      isNewMessageAlertActive: isNewMessageAlertActive == freezed
          ? _value.isNewMessageAlertActive
          : isNewMessageAlertActive // ignore: cast_nullable_to_non_nullable
              as bool,
      isLikeNotificationActive: isLikeNotificationActive == freezed
          ? _value.isLikeNotificationActive
          : isLikeNotificationActive // ignore: cast_nullable_to_non_nullable
              as bool,
      isChatTimerNotificationActive: isChatTimerNotificationActive == freezed
          ? _value.isChatTimerNotificationActive
          : isChatTimerNotificationActive // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$NotificationStateCopyWith<$Res>
    implements $NotificationStateCopyWith<$Res> {
  factory _$NotificationStateCopyWith(
          _NotificationState value, $Res Function(_NotificationState) then) =
      __$NotificationStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {Option<StreamSubscription> notificationSubscription,
      bool isLoading,
      bool isInitialized,
      bool isPushNotificationActive,
      bool isNewMessageAlertActive,
      bool isLikeNotificationActive,
      bool isChatTimerNotificationActive});
}

/// @nodoc
class __$NotificationStateCopyWithImpl<$Res>
    extends _$NotificationStateCopyWithImpl<$Res>
    implements _$NotificationStateCopyWith<$Res> {
  __$NotificationStateCopyWithImpl(
      _NotificationState _value, $Res Function(_NotificationState) _then)
      : super(_value, (v) => _then(v as _NotificationState));

  @override
  _NotificationState get _value => super._value as _NotificationState;

  @override
  $Res call({
    Object? notificationSubscription = freezed,
    Object? isLoading = freezed,
    Object? isInitialized = freezed,
    Object? isPushNotificationActive = freezed,
    Object? isNewMessageAlertActive = freezed,
    Object? isLikeNotificationActive = freezed,
    Object? isChatTimerNotificationActive = freezed,
  }) {
    return _then(_NotificationState(
      notificationSubscription: notificationSubscription == freezed
          ? _value.notificationSubscription
          : notificationSubscription // ignore: cast_nullable_to_non_nullable
              as Option<StreamSubscription>,
      isLoading: isLoading == freezed
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      isInitialized: isInitialized == freezed
          ? _value.isInitialized
          : isInitialized // ignore: cast_nullable_to_non_nullable
              as bool,
      isPushNotificationActive: isPushNotificationActive == freezed
          ? _value.isPushNotificationActive
          : isPushNotificationActive // ignore: cast_nullable_to_non_nullable
              as bool,
      isNewMessageAlertActive: isNewMessageAlertActive == freezed
          ? _value.isNewMessageAlertActive
          : isNewMessageAlertActive // ignore: cast_nullable_to_non_nullable
              as bool,
      isLikeNotificationActive: isLikeNotificationActive == freezed
          ? _value.isLikeNotificationActive
          : isLikeNotificationActive // ignore: cast_nullable_to_non_nullable
              as bool,
      isChatTimerNotificationActive: isChatTimerNotificationActive == freezed
          ? _value.isChatTimerNotificationActive
          : isChatTimerNotificationActive // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_NotificationState implements _NotificationState {
  const _$_NotificationState(
      {required this.notificationSubscription,
      required this.isLoading,
      required this.isInitialized,
      required this.isPushNotificationActive,
      required this.isNewMessageAlertActive,
      required this.isLikeNotificationActive,
      required this.isChatTimerNotificationActive});

  @override
  final Option<StreamSubscription> notificationSubscription;
  @override
  final bool isLoading;
  @override
  final bool isInitialized;
  @override
  final bool isPushNotificationActive;
  @override
  final bool isNewMessageAlertActive;
  @override
  final bool isLikeNotificationActive;
  @override
  final bool isChatTimerNotificationActive;

  @override
  String toString() {
    return 'NotificationState(notificationSubscription: $notificationSubscription, isLoading: $isLoading, isInitialized: $isInitialized, isPushNotificationActive: $isPushNotificationActive, isNewMessageAlertActive: $isNewMessageAlertActive, isLikeNotificationActive: $isLikeNotificationActive, isChatTimerNotificationActive: $isChatTimerNotificationActive)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _NotificationState &&
            (identical(
                    other.notificationSubscription, notificationSubscription) ||
                other.notificationSubscription == notificationSubscription) &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.isInitialized, isInitialized) ||
                other.isInitialized == isInitialized) &&
            (identical(
                    other.isPushNotificationActive, isPushNotificationActive) ||
                other.isPushNotificationActive == isPushNotificationActive) &&
            (identical(
                    other.isNewMessageAlertActive, isNewMessageAlertActive) ||
                other.isNewMessageAlertActive == isNewMessageAlertActive) &&
            (identical(
                    other.isLikeNotificationActive, isLikeNotificationActive) ||
                other.isLikeNotificationActive == isLikeNotificationActive) &&
            (identical(other.isChatTimerNotificationActive,
                    isChatTimerNotificationActive) ||
                other.isChatTimerNotificationActive ==
                    isChatTimerNotificationActive));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      notificationSubscription,
      isLoading,
      isInitialized,
      isPushNotificationActive,
      isNewMessageAlertActive,
      isLikeNotificationActive,
      isChatTimerNotificationActive);

  @JsonKey(ignore: true)
  @override
  _$NotificationStateCopyWith<_NotificationState> get copyWith =>
      __$NotificationStateCopyWithImpl<_NotificationState>(this, _$identity);
}

abstract class _NotificationState implements NotificationState {
  const factory _NotificationState(
      {required Option<StreamSubscription> notificationSubscription,
      required bool isLoading,
      required bool isInitialized,
      required bool isPushNotificationActive,
      required bool isNewMessageAlertActive,
      required bool isLikeNotificationActive,
      required bool isChatTimerNotificationActive}) = _$_NotificationState;

  @override
  Option<StreamSubscription> get notificationSubscription;
  @override
  bool get isLoading;
  @override
  bool get isInitialized;
  @override
  bool get isPushNotificationActive;
  @override
  bool get isNewMessageAlertActive;
  @override
  bool get isLikeNotificationActive;
  @override
  bool get isChatTimerNotificationActive;
  @override
  @JsonKey(ignore: true)
  _$NotificationStateCopyWith<_NotificationState> get copyWith =>
      throw _privateConstructorUsedError;
}
