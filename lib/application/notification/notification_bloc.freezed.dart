// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'notification_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$NotificationEventTearOff {
  const _$NotificationEventTearOff();

  _LoadSettings loadSettings() {
    return const _LoadSettings();
  }

  _TogglePushNotification togglePushNotification() {
    return const _TogglePushNotification();
  }
}

/// @nodoc
const $NotificationEvent = _$NotificationEventTearOff();

/// @nodoc
mixin _$NotificationEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadSettings,
    required TResult Function() togglePushNotification,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loadSettings,
    TResult Function()? togglePushNotification,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadSettings,
    TResult Function()? togglePushNotification,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadSettings value) loadSettings,
    required TResult Function(_TogglePushNotification value)
        togglePushNotification,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LoadSettings value)? loadSettings,
    TResult Function(_TogglePushNotification value)? togglePushNotification,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadSettings value)? loadSettings,
    TResult Function(_TogglePushNotification value)? togglePushNotification,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NotificationEventCopyWith<$Res> {
  factory $NotificationEventCopyWith(
          NotificationEvent value, $Res Function(NotificationEvent) then) =
      _$NotificationEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$NotificationEventCopyWithImpl<$Res>
    implements $NotificationEventCopyWith<$Res> {
  _$NotificationEventCopyWithImpl(this._value, this._then);

  final NotificationEvent _value;
  // ignore: unused_field
  final $Res Function(NotificationEvent) _then;
}

/// @nodoc
abstract class _$LoadSettingsCopyWith<$Res> {
  factory _$LoadSettingsCopyWith(
          _LoadSettings value, $Res Function(_LoadSettings) then) =
      __$LoadSettingsCopyWithImpl<$Res>;
}

/// @nodoc
class __$LoadSettingsCopyWithImpl<$Res>
    extends _$NotificationEventCopyWithImpl<$Res>
    implements _$LoadSettingsCopyWith<$Res> {
  __$LoadSettingsCopyWithImpl(
      _LoadSettings _value, $Res Function(_LoadSettings) _then)
      : super(_value, (v) => _then(v as _LoadSettings));

  @override
  _LoadSettings get _value => super._value as _LoadSettings;
}

/// @nodoc

class _$_LoadSettings implements _LoadSettings {
  const _$_LoadSettings();

  @override
  String toString() {
    return 'NotificationEvent.loadSettings()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _LoadSettings);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadSettings,
    required TResult Function() togglePushNotification,
  }) {
    return loadSettings();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loadSettings,
    TResult Function()? togglePushNotification,
  }) {
    return loadSettings?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadSettings,
    TResult Function()? togglePushNotification,
    required TResult orElse(),
  }) {
    if (loadSettings != null) {
      return loadSettings();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadSettings value) loadSettings,
    required TResult Function(_TogglePushNotification value)
        togglePushNotification,
  }) {
    return loadSettings(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LoadSettings value)? loadSettings,
    TResult Function(_TogglePushNotification value)? togglePushNotification,
  }) {
    return loadSettings?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadSettings value)? loadSettings,
    TResult Function(_TogglePushNotification value)? togglePushNotification,
    required TResult orElse(),
  }) {
    if (loadSettings != null) {
      return loadSettings(this);
    }
    return orElse();
  }
}

abstract class _LoadSettings implements NotificationEvent {
  const factory _LoadSettings() = _$_LoadSettings;
}

/// @nodoc
abstract class _$TogglePushNotificationCopyWith<$Res> {
  factory _$TogglePushNotificationCopyWith(_TogglePushNotification value,
          $Res Function(_TogglePushNotification) then) =
      __$TogglePushNotificationCopyWithImpl<$Res>;
}

/// @nodoc
class __$TogglePushNotificationCopyWithImpl<$Res>
    extends _$NotificationEventCopyWithImpl<$Res>
    implements _$TogglePushNotificationCopyWith<$Res> {
  __$TogglePushNotificationCopyWithImpl(_TogglePushNotification _value,
      $Res Function(_TogglePushNotification) _then)
      : super(_value, (v) => _then(v as _TogglePushNotification));

  @override
  _TogglePushNotification get _value => super._value as _TogglePushNotification;
}

/// @nodoc

class _$_TogglePushNotification implements _TogglePushNotification {
  const _$_TogglePushNotification();

  @override
  String toString() {
    return 'NotificationEvent.togglePushNotification()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _TogglePushNotification);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadSettings,
    required TResult Function() togglePushNotification,
  }) {
    return togglePushNotification();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loadSettings,
    TResult Function()? togglePushNotification,
  }) {
    return togglePushNotification?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadSettings,
    TResult Function()? togglePushNotification,
    required TResult orElse(),
  }) {
    if (togglePushNotification != null) {
      return togglePushNotification();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadSettings value) loadSettings,
    required TResult Function(_TogglePushNotification value)
        togglePushNotification,
  }) {
    return togglePushNotification(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LoadSettings value)? loadSettings,
    TResult Function(_TogglePushNotification value)? togglePushNotification,
  }) {
    return togglePushNotification?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadSettings value)? loadSettings,
    TResult Function(_TogglePushNotification value)? togglePushNotification,
    required TResult orElse(),
  }) {
    if (togglePushNotification != null) {
      return togglePushNotification(this);
    }
    return orElse();
  }
}

abstract class _TogglePushNotification implements NotificationEvent {
  const factory _TogglePushNotification() = _$_TogglePushNotification;
}

/// @nodoc
class _$NotificationStateTearOff {
  const _$NotificationStateTearOff();

  _NotificationState call(
      {required bool isPushNotificationActive,
      required bool isNewMessageAlertActive,
      required bool isLikeNotificationActive,
      required bool isChatTimerNotificationActive}) {
    return _NotificationState(
      isPushNotificationActive: isPushNotificationActive,
      isNewMessageAlertActive: isNewMessageAlertActive,
      isLikeNotificationActive: isLikeNotificationActive,
      isChatTimerNotificationActive: isChatTimerNotificationActive,
    );
  }
}

/// @nodoc
const $NotificationState = _$NotificationStateTearOff();

/// @nodoc
mixin _$NotificationState {
  bool get isPushNotificationActive => throw _privateConstructorUsedError;
  bool get isNewMessageAlertActive => throw _privateConstructorUsedError;
  bool get isLikeNotificationActive => throw _privateConstructorUsedError;
  bool get isChatTimerNotificationActive => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $NotificationStateCopyWith<NotificationState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NotificationStateCopyWith<$Res> {
  factory $NotificationStateCopyWith(
          NotificationState value, $Res Function(NotificationState) then) =
      _$NotificationStateCopyWithImpl<$Res>;
  $Res call(
      {bool isPushNotificationActive,
      bool isNewMessageAlertActive,
      bool isLikeNotificationActive,
      bool isChatTimerNotificationActive});
}

/// @nodoc
class _$NotificationStateCopyWithImpl<$Res>
    implements $NotificationStateCopyWith<$Res> {
  _$NotificationStateCopyWithImpl(this._value, this._then);

  final NotificationState _value;
  // ignore: unused_field
  final $Res Function(NotificationState) _then;

  @override
  $Res call({
    Object? isPushNotificationActive = freezed,
    Object? isNewMessageAlertActive = freezed,
    Object? isLikeNotificationActive = freezed,
    Object? isChatTimerNotificationActive = freezed,
  }) {
    return _then(_value.copyWith(
      isPushNotificationActive: isPushNotificationActive == freezed
          ? _value.isPushNotificationActive
          : isPushNotificationActive // ignore: cast_nullable_to_non_nullable
              as bool,
      isNewMessageAlertActive: isNewMessageAlertActive == freezed
          ? _value.isNewMessageAlertActive
          : isNewMessageAlertActive // ignore: cast_nullable_to_non_nullable
              as bool,
      isLikeNotificationActive: isLikeNotificationActive == freezed
          ? _value.isLikeNotificationActive
          : isLikeNotificationActive // ignore: cast_nullable_to_non_nullable
              as bool,
      isChatTimerNotificationActive: isChatTimerNotificationActive == freezed
          ? _value.isChatTimerNotificationActive
          : isChatTimerNotificationActive // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$NotificationStateCopyWith<$Res>
    implements $NotificationStateCopyWith<$Res> {
  factory _$NotificationStateCopyWith(
          _NotificationState value, $Res Function(_NotificationState) then) =
      __$NotificationStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {bool isPushNotificationActive,
      bool isNewMessageAlertActive,
      bool isLikeNotificationActive,
      bool isChatTimerNotificationActive});
}

/// @nodoc
class __$NotificationStateCopyWithImpl<$Res>
    extends _$NotificationStateCopyWithImpl<$Res>
    implements _$NotificationStateCopyWith<$Res> {
  __$NotificationStateCopyWithImpl(
      _NotificationState _value, $Res Function(_NotificationState) _then)
      : super(_value, (v) => _then(v as _NotificationState));

  @override
  _NotificationState get _value => super._value as _NotificationState;

  @override
  $Res call({
    Object? isPushNotificationActive = freezed,
    Object? isNewMessageAlertActive = freezed,
    Object? isLikeNotificationActive = freezed,
    Object? isChatTimerNotificationActive = freezed,
  }) {
    return _then(_NotificationState(
      isPushNotificationActive: isPushNotificationActive == freezed
          ? _value.isPushNotificationActive
          : isPushNotificationActive // ignore: cast_nullable_to_non_nullable
              as bool,
      isNewMessageAlertActive: isNewMessageAlertActive == freezed
          ? _value.isNewMessageAlertActive
          : isNewMessageAlertActive // ignore: cast_nullable_to_non_nullable
              as bool,
      isLikeNotificationActive: isLikeNotificationActive == freezed
          ? _value.isLikeNotificationActive
          : isLikeNotificationActive // ignore: cast_nullable_to_non_nullable
              as bool,
      isChatTimerNotificationActive: isChatTimerNotificationActive == freezed
          ? _value.isChatTimerNotificationActive
          : isChatTimerNotificationActive // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_NotificationState implements _NotificationState {
  const _$_NotificationState(
      {required this.isPushNotificationActive,
      required this.isNewMessageAlertActive,
      required this.isLikeNotificationActive,
      required this.isChatTimerNotificationActive});

  @override
  final bool isPushNotificationActive;
  @override
  final bool isNewMessageAlertActive;
  @override
  final bool isLikeNotificationActive;
  @override
  final bool isChatTimerNotificationActive;

  @override
  String toString() {
    return 'NotificationState(isPushNotificationActive: $isPushNotificationActive, isNewMessageAlertActive: $isNewMessageAlertActive, isLikeNotificationActive: $isLikeNotificationActive, isChatTimerNotificationActive: $isChatTimerNotificationActive)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _NotificationState &&
            (identical(
                    other.isPushNotificationActive, isPushNotificationActive) ||
                other.isPushNotificationActive == isPushNotificationActive) &&
            (identical(
                    other.isNewMessageAlertActive, isNewMessageAlertActive) ||
                other.isNewMessageAlertActive == isNewMessageAlertActive) &&
            (identical(
                    other.isLikeNotificationActive, isLikeNotificationActive) ||
                other.isLikeNotificationActive == isLikeNotificationActive) &&
            (identical(other.isChatTimerNotificationActive,
                    isChatTimerNotificationActive) ||
                other.isChatTimerNotificationActive ==
                    isChatTimerNotificationActive));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      isPushNotificationActive,
      isNewMessageAlertActive,
      isLikeNotificationActive,
      isChatTimerNotificationActive);

  @JsonKey(ignore: true)
  @override
  _$NotificationStateCopyWith<_NotificationState> get copyWith =>
      __$NotificationStateCopyWithImpl<_NotificationState>(this, _$identity);
}

abstract class _NotificationState implements NotificationState {
  const factory _NotificationState(
      {required bool isPushNotificationActive,
      required bool isNewMessageAlertActive,
      required bool isLikeNotificationActive,
      required bool isChatTimerNotificationActive}) = _$_NotificationState;

  @override
  bool get isPushNotificationActive;
  @override
  bool get isNewMessageAlertActive;
  @override
  bool get isLikeNotificationActive;
  @override
  bool get isChatTimerNotificationActive;
  @override
  @JsonKey(ignore: true)
  _$NotificationStateCopyWith<_NotificationState> get copyWith =>
      throw _privateConstructorUsedError;
}
